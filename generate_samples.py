#!/usr/bin/env python3
"""
Génère automatiquement le code C++ pour accéder aux samples WAV embarqués.
Appelé par CMake lors du build.
"""
import os
import sys
from pathlib import Path

def sanitize_name(path):
    """Convertit un chemin de fichier en nom C++ valide."""
    # Retire extension et répertoire samples/
    name = path.stem
    # Remplace caractères invalides par underscore
    name = ''.join(c if c.isalnum() else '_' for c in name)
    # Évite noms commençant par chiffre
    if name[0].isdigit():
        name = '_' + name
    return name.upper()

def get_category(relative_path):
    """Extrait la catégorie depuis le chemin (premier sous-dossier)."""
    parts = Path(relative_path).parts
    if len(parts) > 1:
        return parts[0].upper()
    return "UNCATEGORIZED"

def generate_header(samples_dir, output_file, project_root):
    """Génère le fichier header avec enum et accesseurs."""
    
    samples_path = Path(samples_dir)
    project_path = Path(project_root)
    
    if not samples_path.exists():
        print(f"Error: samples directory '{samples_dir}' not found")
        sys.exit(1)
    
    # Trouve tous les WAV récursivement
    wav_files = sorted(samples_path.rglob('*.wav'))
    
    if not wav_files:
        print(f"Warning: no .wav files found in {samples_dir}")
    
    # Prépare données pour génération
    samples_data = []
    for wav_file in wav_files:
        rel_path = wav_file.relative_to(samples_path)
        enum_name = sanitize_name(wav_file)
        category = get_category(rel_path)
        
        # Générer le symbole exact comme objcopy le fait (chemin absolu complet)
        full_path = wav_file.resolve()
        # objcopy remplace tout sauf alphanum par _
        symbol_path = str(full_path).replace('/', '_').replace('.', '_').replace('-', '_').replace(' ', '_')
        
        samples_data.append({
            'enum_name': enum_name,
            'category': category,
            'rel_path': str(rel_path),
            'filename': wav_file.name,
            'safe_name': wav_file.stem.replace('-', '_').replace(' ', '_'),
            'symbol_path': symbol_path  # Utilisé pour les symboles extern
        })
    
    # Génère le header
    with open(output_file, 'w') as f:
        f.write("""#pragma once
// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by generate_samples.py
#include <stdint.h>
#include <string.h>

// WAV header structure
struct WavHeader {
    char riff[4];
    uint32_t file_size;
    char wave[4];
    char fmt[4];
    uint32_t fmt_size;
    uint16_t format;
    uint16_t channels;
    uint32_t sample_rate;
    uint32_t byte_rate;
    uint16_t block_align;
    uint16_t bits_per_sample;
    char data[4];
    uint32_t data_size;
};

""")
        
        # Enum des samples
        f.write("// Sample IDs\n")
        f.write("enum class SampleID {\n")
        for i, sample in enumerate(samples_data):
            f.write(f"    {sample['enum_name']} = {i},\n")
        f.write(f"    COUNT = {len(samples_data)}\n")
        f.write("};\n\n")
        
        # Déclarations extern pour chaque sample
        f.write("// Binary blob symbols (injected by linker)\n")
        f.write("extern \"C\" {\n")
        for sample in samples_data:
            # Utiliser le chemin de symbole exact généré par objcopy
            f.write(f"    // {sample['rel_path']}\n")
            f.write(f"    extern const unsigned char _binary_{sample['symbol_path']}_start[];\n")
            f.write(f"    extern const unsigned char _binary_{sample['symbol_path']}_end[];\n")
        f.write("}\n\n")
        
        # Structure d'info sample
        f.write("""// Sample information structure
struct SampleInfo {
    const char* name;
    const char* category;
    const int16_t* data;
    uint32_t length;
    float root_freq;  // Hz (override in code if needed)
};

""")
        
        # Fonction helper pour obtenir PCM data
        f.write("// Helper to extract PCM data from WAV blob\n")
        f.write("inline const int16_t* get_pcm_data(const unsigned char* wav_start) {\n")
        f.write("    return reinterpret_cast<const int16_t*>(wav_start + 44);\n")
        f.write("}\n\n")
        
        f.write("inline uint32_t get_pcm_length(const unsigned char* wav_start) {\n")
        f.write("    const WavHeader* hdr = reinterpret_cast<const WavHeader*>(wav_start);\n")
        f.write("    return hdr->data_size / 2;  // Convert bytes to samples\n")
        f.write("}\n\n")
        
        # Table de samples
        f.write("// Sample lookup table\n")
        f.write("inline const SampleInfo* get_sample_bank() {\n")
        f.write("    static const SampleInfo bank[] = {\n")
        
        for sample in samples_data:
            sym = sample['symbol_path']
            f.write(f"        {{ \"{sample['filename']}\", \"{sample['category']}\",\n")
            f.write(f"          get_pcm_data(_binary_{sym}_start),\n")
            f.write(f"          get_pcm_length(_binary_{sym}_start),\n")
            f.write(f"          440.0f }},  // {sample['rel_path']}\n")
        
        f.write("    };\n")
        f.write("    return bank;\n")
        f.write("}\n\n")
        
        # Accesseur par ID
        f.write("inline const SampleInfo& get_sample_info(SampleID id) {\n")
        f.write("    return get_sample_bank()[static_cast<int>(id)];\n")
        f.write("}\n\n")
        
        f.write("inline int get_sample_count() {\n")
        f.write(f"    return static_cast<int>(SampleID::COUNT);\n")
        f.write("}\n\n")
        
        # Helper pour chercher par nom
        f.write("// Find sample by name (returns -1 if not found)\n")
        f.write("inline int find_sample_by_name(const char* name) {\n")
        f.write("    const SampleInfo* bank = get_sample_bank();\n")
        f.write("    for (int i = 0; i < get_sample_count(); ++i) {\n")
        f.write("        if (strcmp(bank[i].name, name) == 0) return i;\n")
        f.write("    }\n")
        f.write("    return -1;\n")
        f.write("}\n")
    
    print(f"Generated {output_file} with {len(samples_data)} samples")
    for sample in samples_data:
        print(f"  [{sample['category']}] {sample['enum_name']} -> {sample['rel_path']}")

if __name__ == '__main__':
    if len(sys.argv) != 4:
        print("Usage: generate_samples.py <samples_dir> <output_header> <project_root>")
        sys.exit(1)
    
    samples_dir = sys.argv[1]
    output_file = sys.argv[2]
    project_root = sys.argv[3]
    
    generate_header(samples_dir, output_file, project_root)
